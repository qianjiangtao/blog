---
title: 浅谈分布式服务协调技术Zookeeper
date: 2018-08-30 13:55:57
categories:
- Zookeeper
tags:
- Zookeeper
---





参考1Paxos、Raft、Zab :http://www.cnblogs.com/bangerlee/p/5991417.html

https://www.cnblogs.com/bangerlee/p/6216997.html

http://www.linkedkeeper.com/1014.html

http://www.jasongj.com/zookeeper/fastleaderelection/

https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/index.html

### 分布式系统



#### 什么是分布式系统

​	分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是**利用更多的机器，处理更多的数据**。 简单的说如下图，我们将三个机器通过网络将其连在一起构成一个用户服务，对于调用方来说这个系统是透明的跟调用单台服务没什么区别，我们就可以把这种系统称作一个**分布式系统**。 

![1535597734365](D:\myImage\my-image\zookeeper\1535597734365.png)

​	那么分布式系统怎么将任务分发到这些计算机节点呢，很简单的思想，分而治之，即分片（**partition）**。对于计算，那么就是对计算任务进行切换，每个节点算一些，最终汇总就行了，这就是`MapReduce`的思想；对于存储，更好理解一下，每个节点存一部分数据就行了。当数据规模变大的时候，Partition是唯一的选择，同时也会带来一些好处： 

- 1).提升性能和并发，操作被分发到不同的分片，相互独立
- 2).提升系统的可用性，即使部分分片不能用，其他分片不会受到影响



#### 分布式系统面临的挑战



1.异构的机器与网络

​	分布式系统中的机器，配置不一样，其上运行的服务也可能由不同的语言、架构实现，因此处理能力也不一样；节点间通过网络连接，而不同网络运营商提供的网络的带宽、延时、丢包率又不一样。

2.不可靠的网络

​	节点间通过网络通信，而网络是不可靠的。可能的网络问题包括：网络分割、延时、丢包、乱序 

3.网络分区(脑裂)

​	当网络发生异常导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式架构的所有节点，只有部分节点能够正常通信



### 分布式协调技术

​	分布式协调技术主要用来解决分布式环境当中多个进程之间的同步控制，让他们有序的去访问某种临界资源，防止造成"脏数据"的后果 。比如：在分布式系统中多台机器同时访问修改某个共享资源，我们不希望他们同时访问，这时候我们就需要一个**协调器**来协调有序的进行访问共享资源，就想单节点中多线程中锁的概念，也是在分布式环境中分布式锁的思想。

![1535599394301](D:\myImage\my-image\zookeeper\1535599394301.png)

如何实现这样的一个分布式协调器呢？这样的协调器有什么样的要求呢?

- 1.高可用：每个请求都能够收到一个响应，无论响应成功或者失败
- 2.高性能：高性能就不用说了
- 3.一致性：所有节点上的数据，时刻保持一致



### 分布式协调技术的实现Zookeeper



#### ZooKeeper介绍

ZooKeeper是一种为分布式应用所设计的高可用、高性能且一致的开源协调服务，它提供了一项基本服务：**分布式锁服务**。由于ZooKeeper的开源特性，后来我们的开发者在分布式锁的基础上，摸索了出了其他的使用方法：**配置维护、组服务、分布式消息队列**、**分布式通知/协调**等。 



> **注意**：ZooKeepe性能上的特点决定了它能够用在大型的、分布式的系统当中。从**可靠性**方面来说，它并不会因为一个节点的错误而崩溃。除此之外，它**严格的序列访问控制**意味着复杂的控制原语可以应用在客户端上。ZooKeeper在一致性、可用性、容错性的保证，也是ZooKeeper的成功之处，它获得的一切成功都与它采用的协议——Zab协议是密不可分的，这些内容将会在后面介绍。





#### Zookeeper的结构



**Leader：**一个Zookeeper集群同一时间只会有一个实际工作的Leader，它会发起并维护与各Follwer及Observer间的心跳。所有的写操作必须要通过Leader完成再由Leader将写操作广播给其它服务器。 

**Follower：**一个Zookeeper集群可能同时存在多个Follower，它会响应Leader的心跳。Follower可直接处理并返回客户端的读请求，同时会将写请求转发给Leader处理，并且负责在Leader处理写请求时对请求进行投票。 

**Observer：**角色与Follower类似，但是无投票权。 是对follower的拓展



![1535619831686](D:\myImage\my-image\zookeeper\1535619831686.png)





#### Zookeeper的数据模型



ZooKeeper的数据模型，在结构上和标准文件系统的非常相似，都是采用这种树形层次结构，ZooKeeper树中的每个节点被称为—Znode。和文件系统的目录树一样，ZooKeeper树中的每个节点可以拥有子节点。但也有不同之处： 

![1535612215994](C:\Users\QIANJI~1\AppData\Local\Temp\1535612215994.png)

**(1)** **Znode结构**

Znode既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分。图中的每个节点称为一个Znode。 每个Znode由3部分组成:

**①** stat：此为状态信息, 描述该Znode的版本, 权限等信息

**②** data：与该Znode关联的数据

**③** children：该Znode下的子节点

**(2) 数据访问**

ZooKeeper中的每个节点存储的数据要被**原子性的操作**。也就是说读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。

**(3) 节点类型**

ZooKeeper中的节点有两种，分别为**临时节点**和**永久节点**。节点的类型在创建时即被确定，并且不能改变。

**① 临时节点(EPHEMERAL)** 

该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，ZooKeeper的临时节点不允许拥有子节点。

**② 永久节点(PERSISTENT)**

该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。

**③顺序节点(PERSISTENT_SEQUENTIAL)**

当创建Znode的时候，用户可以请求在ZooKeeper的路径结尾添加一个**递增的计数**。这个计数**对于此节点的父节点来说**是唯一的，它的格式为"%10d"(10位数字，没有数值的数位用0补充，例如"0000000001")。当计数值大于232-1时，计数器将溢出。

**(4) 观察**

客户端可以在节点上设置watch，我们称之为**监视器**。当节点状态发生改变时(Znode的增、删、改)将会触发watch所对应的操作。当watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为**watch只能被触发一次**，这样可以减少网络流量



### Zookeeper的实现原理



#### Zookeeper与CAP的关系



> 在说zookeeper原理之前先介绍下CAP理论，作为一个分布式系统，分区容错性是一个必须要考虑的关键点。一个分布式系统一旦丧失了分区容错性，也就表示放弃了扩展性。因为在分布式系统中，网络故障是经常出现的，一旦出现在这种问题就会导致整个系统不可用是绝对不能容忍的。所以，大部分分布式系统都会在保证分区容错性的前提下在一致性和可用性之间做权衡。 

![1535608441399](D:\myImage\my-image\zookeeper\1535608441399.png)

ZooKeeper是个CP（一致性+分区容错性）的，即任何时刻对ZooKeeper的访问请求能得到一致的数据结果，同时系统对网络分割具备容错性；但是它不能保证每次服务请求的可用性。也就是在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。 



#### Zookeeper的实现原理分析



**Zookeeper Service网络结构**

Zookeeper的工作集群可以简单分成两类，一个是Leader，唯一一个，其余的都是follower，如何确定Leader是通过内部选举确定的。

![1535619898860](D:\myImage\my-image\zookeeper\1535619898860.png)

- Leader和各个follower是互相通信的，对于Zookeeper系统的数据都是保存在内存里面的，同样也会备份一份在磁盘上。
- 如果Leader挂了，Zookeeper集群会重新选举，在毫秒级别就会重新选举出一个Leader。
- 集群中除非有一半以上的Zookeeper节点挂了，Zookeeper Service才不可用。



**Zookeeper读写数据** 

![1535620642448](D:\myImage\my-image\zookeeper\1535620642448.png)

- 写数据，一个客户端进行写数据请求时，如果是follower接收到写请求，就会把请求转发给Leader，Leader通过内部的Zab协议进行原子广播，直到所有Zookeeper节点都成功写了数据后（内存同步以及磁盘更新），这次写请求算是完成，然后Zookeeper Service就会给Client发回响应。
- 读数据，因为集群中所有的Zookeeper节点都呈现一个同样的命名空间视图（就是结构数据），上面的写请求已经保证了写一次数据必须保证集群所有的Zookeeper节点都是同步命名空间的，所以读的时候可以在任意一台Zookeeper节点上。

**Leader 选举**

**4.消息广播**

### ZooKeeper应用场景

#### 1,数据发布与订阅

#### 2,统一命名服务（Name Service）

####3,分布通知/协调（Distribution of notification/coordination）

#### 4,分布式锁（Distribute Lock）

https://www.cnblogs.com/sunddenly/p/4092654.html

